### django-computedfields ###

django-computedfields provides autogenerated autoupdated database fields
for model decorator functions.

Tested with Django 2.11 and 2.0.


#### Example ####

Just derive your model from `ComputedFieldsModel` and place
the `@computed` at a method:

```python
from django.db import models
from computedfields.models import ComputedFieldsModel, computed


class MyModel(ComputedFieldsModel):
    name = models.CharField(max_length=32)
    
    @computed(models.CharField(max_length=32))
    def computed_field(self):
        return 'My fancy name is %s.' % self.name
```

`computed_field` will be turned into a real database field
and can be accessed and searched like any other database field.
During saving the associated method gets called and it’s result
written to the database. With the method `compute('fieldname')`
you can inspect the value that will be written, which is useful
if you have pending changes:

```python
>>> person = MyModel(forename='Berty')
>>> person.computed_field             # empty since not saved yet
>>> person.compute('computed_field')  # outputs 'My fancy name is Berty.'
>>> person.save()
>>> person.computed_field             # outputs 'My fancy name is Berty.'
```

The `computed` decorator supports a `depends` keyword argument
to indicate dependencies to other model fields. If set, the computed field
gets automatically updated upon changes of the related fields.


#### Documentation ####

See the docs folder.


#### TODO ####

- support one2one relations
- better reducing of m2m dependency updates
- cleanup messy dependency resolver map creation
- advanced test cases with mixed dependencies
- dependencies with Django’s F objects
- eval usage of stored procedures and complex annotations
